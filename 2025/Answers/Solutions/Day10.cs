using System;
using System.Collections.Generic;

namespace AdventOfCode;

[Answer(10)]
public class Day10 : IAnswer
{
	public Solution Solve(string input)
	{
		var part1 = 0;
		var part2 = 0;

		foreach (var line in input.AsSpan().EnumerateLines())
		{
			var target = 0;
			var buttons = 0;
			var span = line[1..];

			// [.##.]
			while (span[0] != ']')
			{
				if (span[0] == '#')
				{
					target |= 1 << buttons;
				}

				buttons++;
				span = span[1..];
			}

			var buttonWirings = new List<int>();

			span = span[2..];

			// (0,1,3) (2,4)
			while (span[0] == '(')
			{
				var mask = 0;
				span = span[1..];

				while (span[0] != ')')
				{
					mask |= 1 << ParseInt(ref span);
				}

				buttonWirings.Add(mask);
				span = span[2..];
			}

			var joltages = new int[buttons];

			buttons = 0;
			span = span[1..];

			// {3,5,4,7}
			while (span[0] != '}')
			{
				joltages[buttons++] = ParseInt(ref span);
			}

			part1 += Solve1(buttonWirings, target);
			part2 += Solve2(buttonWirings, joltages);
		}

		return new(part1.ToString(), part2.ToString());
	}

	private static int ParseInt(ref ReadOnlySpan<char> line)
	{
		var result = 0;

		while (char.IsAsciiDigit(line[0]))
		{
			result = 10 * result + line[0] - '0';
			line = line[1..];
		}

		if (line[0] == ',')
		{
			line = line[1..];
		}

		return result;
	}

	private static int Solve1(List<int> buttonWirings, int target)
	{
		var minPresses = int.MaxValue;
		var queue = new Queue<(int state, int presses, int nextButton)>();
		queue.Enqueue((0, 0, 0));

		while (queue.Count > 0)
		{
			var (state, presses, nextButton) = queue.Dequeue();

			if (state == target)
			{
				minPresses = Math.Min(minPresses, presses);
				continue;
			}

			if (presses >= minPresses)
			{
				continue;
			}

			for (var i = nextButton; i < buttonWirings.Count; i++)
			{
				queue.Enqueue((state ^ buttonWirings[i], presses + 1, i + 1));
			}
		}

		return minPresses;
	}

	//
	// Code below was generated by claude opus 4.5
	//

	// Part 2: Find minimum button presses to reach exact joltage levels
	// Each button increments specific counters by 1, solve system of linear equations
	// Uses Gaussian elimination to reduce to free variables, then searches for optimal solution
	private static int Solve2(List<int> buttonWirings, int[] target)
	{
		int n = target.Length;
		int m = buttonWirings.Count;

		// Build augmented matrix [A | b] where A[i,j] = 1 if button j affects counter i
		var matrix = new (long num, long den)[n, m + 1];

		for (int i = 0; i < n; i++)
		{
			for (int j = 0; j < m; j++)
				matrix[i, j] = ((buttonWirings[j] & (1 << i)) != 0) ? (1, 1) : (0, 1);
			matrix[i, m] = (target[i], 1);
		}

		// Gaussian elimination to reduced row echelon form
		var pivotCol = new int[n];
		for (int i = 0; i < n; i++) pivotCol[i] = -1;

		int row = 0;
		for (int col = 0; col < m && row < n; col++)
		{
			// Find pivot row
			int pivotRow = -1;
			for (int i = row; i < n; i++)
			{
				if (matrix[i, col].num != 0)
				{
					pivotRow = i;
					break;
				}
			}

			if (pivotRow == -1) continue;

			// Swap rows
			if (pivotRow != row)
			{
				for (int j = col; j <= m; j++)
					(matrix[row, j], matrix[pivotRow, j]) = (matrix[pivotRow, j], matrix[row, j]);
			}

			pivotCol[row] = col;

			// Scale pivot row to make pivot = 1
			var pivot = matrix[row, col];
			for (int j = col; j <= m; j++)
			{
				var (an, ad) = matrix[row, j];
				matrix[row, j] = Simplify(an * pivot.den, ad * pivot.num);
			}

			// Eliminate column in all other rows
			for (int i = 0; i < n; i++)
			{
				if (i == row || matrix[i, col].num == 0) continue;
				var factor = matrix[i, col];
				for (int j = col; j <= m; j++)
				{
					var (an, ad) = matrix[i, j];
					var (bn, bd) = matrix[row, j];
					matrix[i, j] = Simplify(an * factor.den * bd - factor.num * bn * ad, ad * factor.den * bd);
				}
			}
			row++;
		}

		int rank = row;

		// Identify free variables (columns without pivots)
		var freeVars = new List<int>();
		for (int j = 0; j < m; j++)
		{
			bool isBasic = false;
			for (int i = 0; i < rank; i++)
			{
				if (pivotCol[i] == j)
				{
					isBasic = true;
					break;
				}
			}
			if (!isBasic) freeVars.Add(j);
		}

		// Build solution expressions: x[j] = constants[j] + sum(coeffs[j,k] * f[k])
		var constants = new (long num, long den)[m];
		var coeffs = new (long num, long den)[m, freeVars.Count];

		for (int j = 0; j < m; j++)
		{
			constants[j] = (0, 1);
			for (int k = 0; k < freeVars.Count; k++)
				coeffs[j, k] = (0, 1);
		}

		// Free variables equal themselves
		for (int k = 0; k < freeVars.Count; k++)
			coeffs[freeVars[k], k] = (1, 1);

		// Basic variables from RREF
		for (int i = 0; i < rank; i++)
		{
			int j = pivotCol[i];
			constants[j] = matrix[i, m];
			for (int k = 0; k < freeVars.Count; k++)
			{
				var (num, den) = matrix[i, freeVars[k]];
				coeffs[j, k] = Simplify(-num, den);
			}
		}

		// No free variables - unique solution
		if (freeVars.Count == 0)
		{
			long total = 0;
			for (int j = 0; j < m; j++)
			{
				var (cn, cd) = constants[j];
				if (cd != 1 || cn < 0) return int.MaxValue;
				total += cn;
			}
			return (int)total;
		}

		// Search over free variable values
		long maxVal = 0;
		foreach (var t in target) maxVal = Math.Max(maxVal, t);
		maxVal *= 2;

		int best = int.MaxValue;
		SearchFree(freeVars.Count, 0, new long[freeVars.Count], maxVal, constants, coeffs, m, ref best);
		return best;
	}

	// Recursively search all combinations of free variable values
	private static void SearchFree(
		int numFree,
		int depth,
		long[] freeValues,
		long maxVal,
		(long num, long den)[] constants,
		(long num, long den)[,] coeffs,
		int numButtons,
		ref int best)
	{
		// Base case: evaluate complete assignment
		if (depth == numFree)
		{
			long total = 0;
			for (int j = 0; j < numButtons; j++)
			{
				long val = EvalButton(j, freeValues, numFree, constants, coeffs);
				if (val < 0) return; // Non-integer or negative - invalid
				total += val;
				if (total >= best) return; // Already worse than best
			}
			best = (int)total;
			return;
		}

		// Try all values for current free variable
		for (long v = 0; v <= maxVal; v++)
		{
			freeValues[depth] = v;

			// Prune: check if any button count is definitely negative
			// Even with remaining free vars at their optimal values
			bool infeasible = false;
			for (int j = 0; j < numButtons && !infeasible; j++)
			{
				// Compute fixed contribution from constant and already-set free vars
				double fixedPart = (double)constants[j].num / constants[j].den;
				for (int k = 0; k <= depth; k++)
				{
					var (an, ad) = coeffs[j, k];
					fixedPart += ((double)an / ad) * freeValues[k];
				}

				// Compute max possible contribution from remaining free vars
				double maxFromRest = 0;
				for (int k = depth + 1; k < numFree; k++)
				{
					var (an, ad) = coeffs[j, k];
					double c = (double)an / ad;
					if (c > 0)
						maxFromRest += c * maxVal;
				}

				// If even best case is negative, prune this branch
				if (fixedPart + maxFromRest < -1e-9)
					infeasible = true;
			}

			if (!infeasible)
				SearchFree(numFree, depth + 1, freeValues, maxVal, constants, coeffs, numButtons, ref best);
		}
	}

	// Evaluate button press count given free variable values
	// Returns -1 if result is not a non-negative integer
	private static long EvalButton(
		int j,
		long[] freeValues,
		int numFree,
		(long num, long den)[] constants,
		(long num, long den)[,] coeffs)
	{
		long num = constants[j].num;
		long den = constants[j].den;

		for (int k = 0; k < numFree; k++)
		{
			var (an, ad) = coeffs[j, k];
			num = num * ad + an * freeValues[k] * den;
			den *= ad;
			var g = Gcd(Math.Abs(num), Math.Abs(den));
			if (g > 1) { num /= g; den /= g; }
		}

		if (den < 0) { num = -num; den = -den; }
		if (den != 1 || num < 0) return -1;
		return num;
	}

	// Simplify a rational number
	private static (long num, long den) Simplify(long num, long den)
	{
		if (den < 0) { num = -num; den = -den; }
		if (num == 0) return (0, 1);
		var g = Gcd(Math.Abs(num), den);
		return (num / g, den / g);
	}

	// Greatest common divisor
	private static long Gcd(long a, long b)
	{
		while (b != 0)
		{
			var t = b;
			b = a % b;
			a = t;
		}
		return a;
	}
}
